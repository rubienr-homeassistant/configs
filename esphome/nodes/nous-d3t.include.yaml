esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  
  on_boot:
    - priority: 600
      then:
        - output.turn_off: relay_on_coil
        - output.turn_off: relay_off_coil
        - output.set_level:
            id: led_link
            level: 0.0
        - script.execute: update_relay_led

esp32:
  board: esp32dev

logger:
#  level: DEBUG

api:
  encryption:
    key: !secret api_key

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    then:
      - output.set_level:
          id: led_link
          level: 0.05
  on_disconnect:
    then:
      - output.set_level:
          id: led_link
          level: 0.0

captive_portal:

time:
  - platform: homeassistant
    id: homeassistant_time

esp32_ble_tracker:

output:
  - platform: gpio
    pin: GPIO5
    id: led_relay
    inverted: true

  - platform: ledc
    pin: GPIO15
    id: led_link
    inverted: true
    frequency: 1000 Hz

  - platform: gpio
    pin: GPIO12
    id: relay_on_coil
    inverted: false
    
  - platform: gpio
    pin: GPIO2
    id: relay_off_coil
    inverted: false

switch:
  # exposes the relais switch to homeassistant
  - platform: template
    name: "Relay"
    id: relay_control
    optimistic: true
    restore_mode: DISABLED # required, otherwise initialization will trigger turn_on_action or turn_off_action
    icon: mdi:power
    turn_on_action:
      - script.execute: toggle_relay
      - lambda: |-
          id(manually_turned_on_s) = millis() / 1000;
    turn_off_action:
      - script.execute: toggle_relay
      - lambda: |-
          id(manually_turned_on_s) = 0;
    lambda: |-
      return id(relay_toggle_state);
      
  # exposes the relais switch to homeassistant
  - platform: template
    name: "Automation Relay (internal)"
    id: relay_control_internal
    optimistic: true
    restore_mode: DISABLED # required, otherwise initialization will trigger turn_on_action or turn_off_action
    icon: mdi:power
    turn_on_action:
      - script.execute: toggle_relay
      - lambda: |-
          id(manually_turned_on_s) = 0;
    turn_off_action:
      - script.execute: toggle_relay
      - lambda: |-
          id(manually_turned_on_s) = 0;
    lambda: |-
      return id(relay_toggle_state);

binary_sensor: # senses the momentary push-button; not exposed to homeassistant
  - platform: gpio
    pin: GPIO0
    id: sensor_toggle
    name: "Button"
    on_press:
      - script.execute: toggle_relay
      - lambda: |-
          id(manually_turned_on_s) = id(relay_toggle_state) ? millis() / 1000 : 0;

globals:
  # bi-stable relay state: off (false), on (true)
  - id: relay_toggle_state
    type: bool
    restore_value: true
    initial_value: 'false'

  - id: manually_turned_on_s
    type: unsigned int
    initial_value: '0'

script:
  - id: update_relay_led
    mode: single
    then:
      - lambda: |-
          if (id(relay_toggle_state))
            id(led_relay).turn_off();
          else
            id(led_relay).turn_on();
   # bi-stable relais abstraction
  - id: toggle_relay
    mode: single
    then:
      - lambda: |-
          if (id(relay_toggle_state)) {
            id(relay_on_coil).turn_off();
            id(relay_off_coil).turn_on();
            id(relay_toggle_state) = false;
          } else {
            id(relay_off_coil).turn_off();
            id(relay_on_coil).turn_on();
            id(relay_toggle_state) = true;
          }
      - script.execute: update_relay_led
      - delay: 300ms
      - output.turn_off: relay_on_coil
      - output.turn_off: relay_off_coil
      
uart:
  id: uart_bl0942
  rx_pin: GPIO13
  baud_rate: 4800
  parity: NONE
  stop_bits: 1

sensor:
  - platform: template
    id: manually_turned_on_since_s
    unit_of_measurement: "s"
    accuracy_decimals: 0
    icon: mdi:timer-outline
    name: "Manually On"
    lambda: |-
      return (float)id(manually_turned_on_s) ? millis() / 1000 - id(manually_turned_on_s) : 0;
    update_interval: 1s

  - platform: bl0942
    uart_id: uart_bl0942
    reset: true
    voltage:
      name: "Voltage"
    current:
      name: "Current"
    power:
      name: "Power"
    energy:
      name: "Total Energy"
    frequency:
      name: "Frequency"
    update_interval: 30s

    # caution: ADC to temp. mapping does not work!
  - platform: adc
    pin: GPIO34
    name: "Temperature Sensor"
    update_interval: 300s
    attenuation: 11db  # Adjust based on your voltage range
    filters:
      - lambda: |-
          const float R25      = 40000.0; // Thermistor resistance at 25°C in ohms
          const float B        =  3950.0; // B-value of the thermistor
          const float Rdivider = 10000.0; // Resistor in voltage divider in ohms (adjust as needed)

          // Convert ADC value (0-1023) to thermistor resistance
          const float adc_voltage = x * (3.3 / 1023.0); // Convert ADC value to voltage (3.3V system)
          const float R           = Rdivider * (3.3 / adc_voltage - 1.0); // Calculate thermistor resistance

          // Steinhart-Hart Equation for temperature calculation
          const float temperatureK = 1.0 / ( (log(R / R25) / B) + (1.0 / 298.15) );  // Steinhart-Hart equation
          const float temperatureC = temperatureK - 273.15;                          // Convert Kelvin to Celsius

          return temperatureC;  // Return the temperature in Celsius
    unit_of_measurement: "°C"
